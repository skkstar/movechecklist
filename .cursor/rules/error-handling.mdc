---
alwaysApply: true
description: Error handling and logging best practices
---

# ğŸš¨ Error Handling & Logging

## ğŸ¯ Error Handling Patterns
- âœ… **Try-catch for all async operations**
- âœ… **User-friendly error messages**
- âœ… **Console logging for debugging**
- âœ… **Error boundaries for React components**
- âœ… **Graceful degradation**

## ğŸ“ Error Handling Template
```typescript
const handleAsyncAction = async () => {
  try {
    setLoading(true);
    setError(null);
    
    const result = await apiCall();
    
    // Success handling
    toast.success('ì‘ì—…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.');
    return result;
    
  } catch (error) {
    console.error('Action failed:', error);
    
    // User-friendly error message
    const errorMessage = error instanceof Error 
      ? error.message 
      : 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
    
    setError(errorMessage);
    toast.error(errorMessage);
    
  } finally {
    setLoading(false);
  }
};
```

## ğŸ” Logging Guidelines
- **Development**: Detailed logging with stack traces
- **Production**: Minimal logging, no sensitive data
- **Structured Logging**: Consistent message format
- **Error Context**: Include relevant data for debugging

## ğŸ¨ User Feedback Patterns
```typescript
// âœ… Loading States
{loading && (
  <div className="flex items-center justify-center p-4">
    <Loader2 className="h-6 w-6 animate-spin" />
    <span className="ml-2">ì²˜ë¦¬ì¤‘...</span>
  </div>
)}

// âœ… Error States
{error && (
  <Alert variant="destructive">
    <AlertCircle className="h-4 w-4" />
    <AlertTitle>ì˜¤ë¥˜ ë°œìƒ</AlertTitle>
    <AlertDescription>{error}</AlertDescription>
  </Alert>
)}

// âœ… Empty States
{!loading && items.length === 0 && (
  <div className="text-center py-8">
    <Inbox className="h-12 w-12 mx-auto text-muted-foreground" />
    <h3 className="mt-4 text-lg font-semibold">ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤</h3>
    <p className="text-muted-foreground">ìƒˆë¡œìš´ í•­ëª©ì„ ì¶”ê°€í•´ë³´ì„¸ìš”.</p>
  </div>
)}
```

## ğŸ›¡ï¸ Error Boundary Implementation
```typescript
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="p-8 text-center">
          <AlertTriangle className="h-12 w-12 mx-auto text-destructive" />
          <h2 className="mt-4 text-xl font-semibold">ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤</h2>
          <p className="text-muted-foreground">í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•´ì£¼ì„¸ìš”.</p>
        </div>
      );
    }

    return this.props.children;
  }
}
```

## ğŸ”„ Retry Mechanisms
- **Network Requests**: Implement retry logic
- **User Actions**: Allow manual retry
- **Exponential Backoff**: For repeated failures
- **Circuit Breaker**: Prevent cascade failures

## ğŸ“Š Error Monitoring
- **Client-side Errors**: Log to console and external service
- **Server Errors**: Monitor API response codes
- **User Experience**: Track error impact on user flow
- **Performance**: Monitor error-related performance issues